import {t} from "@server/init/t";
import {Entity} from "@server/utils/ecs";
import {z} from "zod";

export const timeline = t.router({
  activate: t.procedure
    .meta({action: true})
    .input(z.object({pluginId: z.string(), timelineId: z.string()}))
    .send(({ctx, input}) => {
      if (!ctx.flight) return;
      const timeline = ctx.server.plugins
        .find(plugin => plugin.id === input.pluginId)
        ?.aspects.timelines.find(
          timeline => timeline.name === input.timelineId
        );
      if (!timeline) return;
      // Create the timeline entity
      const timelineEntity = new Entity();
      const stepIds: number[] = [];
      for (let stepItem of timeline.steps) {
        const step = new Entity();
        step.addComponent("identity", {
          name: stepItem.name,
          description: stepItem.description,
        });
        step.addComponent("tags", {tags: stepItem.tags});
        step.addComponent("isTimelineStep", {
          actions: stepItem.actions,
          active: false,
          timelineId: timelineEntity.id,
        });
        ctx.flight.ecs.addEntity(step);
        stepIds.push(step.id);
      }

      timelineEntity.addComponent("identity", {
        name: timeline.name,
        description: timeline.description,
      });
      timelineEntity.addComponent("tags", {tags: timeline.tags});
      timelineEntity.addComponent("isTimeline", {
        steps: stepIds,
        isMission: timeline.isMission,
      });
      ctx.flight.ecs.addEntity(timelineEntity);

      // August 25, 2023 - Send the necessary pubsub updates
      // Also trigger the first step
    }),
  advance: t.procedure
    .meta({action: true})
    .input(
      z.object({
        timelineId: z
          .number()
          .describe(
            "If using in a timeline action trigger, leave blank to advance the current timeline."
          ),
      })
    )
    .send(({ctx, input}) => {
      const timeline = ctx.flight?.ecs.getEntityById(input.timelineId);
      if (!timeline) return;
      const currentStep = timeline.components.isTimeline?.currentStep;
      if (currentStep === undefined) return;
      const steps = timeline.components.isTimeline?.steps;
      if (!steps) return;
      const nextStep = steps[currentStep + 1];
      if (nextStep === undefined) return;
      timeline.updateComponent("isTimeline", {currentStep: currentStep + 1});

      // TODO: August 25, 2023 Send the necessary pubsub updates
    }),
  goToStep: t.procedure
    .meta({action: true})
    .input(z.object({timelineId: z.number(), stepId: z.number()}))
    .send(({ctx, input}) => {
      const timeline = ctx.flight?.ecs.getEntityById(input.timelineId);
      if (!timeline) return;
      const steps = timeline.components.isTimeline?.steps;
      if (!steps) return;
      const step = steps[input.stepId];
      if (!step) return;
      timeline.updateComponent("isTimeline", {currentStep: input.stepId});

      // TODO: August 25, 2023 Send the necessary pubsub updates
    }),
  deactivate: t.procedure
    .meta({action: true})
    .input(z.object({timelineId: z.number()}))
    .send(({ctx, input}) => {
      const timeline = ctx.flight?.ecs.getEntityById(input.timelineId);
      if (!timeline) return;
      const steps = timeline.components.isTimeline?.steps;
      if (!steps) return;
      for (let stepId of steps) {
        const step = ctx.flight?.ecs.getEntityById(stepId);
        if (!step) continue;
        step.updateComponent("isTimelineStep", {active: false});
      }

      // TODO: August 25, 2023 Send the necessary pubsub updates
      // Also, at some point we'll want to make it so every trigger generated by this timeline
      // is deactivated so we don't accidentally re-activate the timeline by triggering one of those triggers
    }),
});
